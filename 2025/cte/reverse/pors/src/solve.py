from z3 import *

# The puzzle definition
areas = [ [0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03],
          [0x00, 0x00, 0x04, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03],
          [0x05, 0x05, 0x04, 0x04, 0x06, 0x06, 0x07, 0x07, 0x07],
          [0x08, 0x05, 0x05, 0x04, 0x09, 0x06, 0x0a, 0x07, 0x07],
          [0x08, 0x08, 0x05, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0a],
          [0x0b, 0x08, 0x0c, 0x09, 0x09, 0x0d, 0x0d, 0x0d, 0x0d],
          [0x0b, 0x0c, 0x0c, 0x0c, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f],
          [0x0b, 0x0c, 0x0e, 0x0e, 0x0e, 0x10, 0x0f, 0x11, 0x11],
          [0x12, 0x12, 0x12, 0x12, 0x0e, 0x10, 0x11, 0x11, 0x11] ]

constraints = [ [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00],
                [0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00],
                [0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01],
                [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
                [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00],
                [0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00],
                [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
                [0x00, 0x05, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00],
                [0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x05, 0x00, 0x01] ]

grid = [[BitVec("x%d%d" % (i,j), 8) for j in range(9)] for i in range(9)]

s = Solver()

for i in range(9):
    for j in range(9):
        s.add(1 <= grid[i][j])
        if constraints[i][j] != 0:
            s.add(grid[i][j] == constraints[i][j])
        s.add(grid[i][j] <= 9)
        if i < 8:
            s.add(grid[i+1][j] != grid[i][j])
            if j < 8:
                s.add(grid[i+1][j+1] != grid[i][j])
            if j > 0:
                s.add(grid[i+1][j-1] != grid[i][j])
        if i > 0:
            s.add(grid[i-1][j] != grid[i][j])
            if j < 8:
                s.add(grid[i-1][j+1] != grid[i][j])
            if j > 0:
                s.add(grid[i-1][j-1] != grid[i][j])
        if j < 8:
            s.add(grid[i][j+1] != grid[i][j])
        if j > 0:
            s.add(grid[i][j-1] != grid[i][j])

c_areas = [0]*0x13
s_areas = [0]*0x13

for i in range(9):
    for j in range(9):
        c_areas[areas[i][j]] += 1
        s_areas[areas[i][j]] += (1 << (grid[i][j] - 1))

for i in range(0x13):
    s.add(s_areas[i] == (1 << c_areas[i]) - 1)

if s.check() == sat:
    m = s.model()
    sol_mat = [[m[grid[i][j]].as_long() for j in range(9)] for i in range(9)]
    sol = ''.join([str(m[grid[i][j]].as_long()) for i in range(9) for j in range(9)])
    print("Solution: %s" % sol)
else:
    print ("[-] Failed to solve puzzle")

s.add(Or([grid[i][j] != sol_mat[i][j] for i in range(9) for j in range(9)]))

if s.check() == unsat:
    print ("[+] Unique solution")
else:
    print ("[-] warning, solution is not unique...")

from pwn import *

io = process('./pors')

io.sendlineafter(b'Enter your input: ', sol.encode())
print(io.recv().decode())
